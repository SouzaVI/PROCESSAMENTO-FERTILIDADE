# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TerramProcessamento
                                 A QGIS plugin
 Krigagem de dados de fertilidade
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-17
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Igor Viana Souza
        email                : igor.souzavigor@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .processamento_dados_dialog import TerramProcessamentoDialog
import os.path

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import *
import processing
import sys, os
from osgeo import ogr
from PyQt5.QtCore import Qt
from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterVectorLayer
import processing
import os # This is is needed in the pyqgis console also
from qgis.core import (QgsVectorLayer)
import math
import qgis.core
from PyQt5.QtCore import QSettings, QVariant 
from qgis.utils import iface
from PyQt5.QtWidgets import QListWidgetItem
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QMessageBox
import geopandas as gpd
from qgis.core import QgsProject, QgsMapLayerType
import os
import random
import pandas as pd



class PerfisIndividuais:
    def __init__(self, dlg):
        #self.dlg = TerramProcessamentoDialog()
        self.dlg = dlg

        # Adicionar atributo fld_list ao ProcessamentoKrigagemOrdinariaDialog
        self.dlg.fld_list = self.dlg.listWidgetAtributos
        self.dlg.fld_list.setSelectionMode(self.dlg.fld_list.ExtendedSelection)

        # Conectar o sinal currentIndexChanged ao método de atualização de campos
        self.dlg.mMapLayerComboBoxPerfil.currentIndexChanged.connect(self.atualizar_campos)

        # Inicializar a lista de campos com a camada atualmente selecionada
        self.atualizar_campos()

    def obter_campos_da_camada(self, layer):
        campos = [field.name() for field in layer.fields()]
        return campos

    def atualizar_campos(self):
        # Obter a camada selecionada no ComboBox
        camada_selecionada = self.dlg.mMapLayerComboBoxPerfil.currentLayer()
        print(camada_selecionada)
        # Verificar se a camada está presente
        if camada_selecionada is not None:
            # Obter os campos da camada selecionada
            lista_campos = self.obter_campos_da_camada(camada_selecionada)

            # Limpar a lista atual e adicionar os novos campos
            self.dlg.fld_list.clear()
            self.dlg.fld_list.addItems(lista_campos)
        else:
            # Caso não haja camada selecionada, você pode lidar com isso da maneira que preferir
            # Por exemplo, limpar a lista de campos ou exibir uma mensagem informativa.
            self.dlg.fld_list.clear()
            print("Nenhuma camada selecionada. Lista de campos foi limpa.")
            # Ou exibir uma mensagem de aviso na interface do usuário, se preferir.
            # QMessageBox.warning(self.dlg, "Aviso", "Nenhuma camada selecionada.")  
            
class TerramProcessamento:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TerramProcessamento_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Terram - Processamento Fertilidade')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        #self.perfis_individuais_instance = PerfisIndividuais()
        
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TerramProcessamento', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/processamento_dados/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Terram - Processamento Fertilidade'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
        


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Terram - Processamento Fertilidade'),
                action)
            self.iface.removeToolBarIcon(action)
    
    
    def exportar_poligono_e_pontos(self):
        camada_fazenda = self.dlg.mMapLayerComboBoxFazenda.currentLayer()
        def export_layer_as_shapefile(layer, output_folder, output_name):
            # Verificar se a camada é válida
            if not layer or not layer.isValid():
                print("Camada inválida.")
                return

            # Criar o caminho completo para o arquivo shapefile de saída
            output_shapefile = os.path.join(output_folder, output_name)

            # Configurar o formato do arquivo shapefile
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = 'ESRI Shapefile'
            options.fileEncoding = 'UTF-8'

            # Configurar o sistema de referência espacial (CRS)
            crs = layer.crs()
            options.destCRS = crs

            # Exportar a camada como shapefile
            success, message = QgsVectorFileWriter.writeAsVectorFormat(layer, output_shapefile, options)
            
            if success == QgsVectorFileWriter.NoError:
                print(f"Camada exportada como shapefile: {output_shapefile}")
            else:
                print(f"Erro ao exportar camada: {message}")

        # Exemplo de uso:
        output_folder = 'C:/geoprocessamento/PROCESSAMENTO/FileQgis/'
        output_name = 'co_original'

        # Certifique-se de ter a camada_fazenda corretamente definida antes de chamar a função
        # camada_fazenda = self.dlg.mMapLayerComboBoxFazenda.currentLayer()

        # Chamar a função de exportação
        export_layer_as_shapefile(camada_fazenda, output_folder, output_name)
   
        def exportar_features_selecionadas(caminho_saida):
        # Obtenha o projeto QGIS
            
            
            # Obtenha o layer ativo no QGIS (certifique-se de que seu layer de polígonos está ativo)
            layer = camada_fazenda
            

            # Verifique se o layer é do tipo vetor (polígono ou multipolígono)
            if layer.geometryType() in [QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygon]:
                # Obtenha as features selecionadas
                selected_features = layer.selectedFeatures()

                # Criar uma lista para armazenar as features exportadas
                exported_features = []

                # Iterar sobre as features selecionadas
                for feature in selected_features:
                    # Obter a geometria e a área
                    geometry = feature.geometry()
                    area = geometry.area()

                    # Adicionar a feature e a área à lista de features exportadas
                    exported_features.append((feature, area))

                # Escrever as features exportadas para um novo shapefile
                QgsVectorFileWriter.writeAsVectorFormat(layer, caminho_saida, 'UTF-8', layer.crs(), 'ESRI Shapefile', onlySelected=True)

                print(f"As features selecionadas foram exportadas para {caminho_saida}")

            else:
                print("O layer ativo não é do tipo polígono ou multipolígono.")
                

        def SelecionarCampos(campos_desejados, shapefile_saida):
            try:
                # Lê a camada de entrada como GeoDataFrame
                gdf = gpd.read_file('C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')

                # Verifica se os campos desejados estão presentes no GeoDataFrame
                campos_faltantes = [campo for campo in campos_desejados if campo not in gdf.columns]

                if campos_faltantes:
                    raise ValueError(f"Os campos {campos_faltantes} não estão presentes na camada de entrada.")

                # Seleciona apenas os campos desejados
                gdf_selecionado = gdf[campos_desejados].copy()

                # Converte o DataFrame resultante de volta para GeoDataFrame
                gdf_selecionado = gpd.GeoDataFrame(gdf_selecionado, geometry=gdf.geometry)

                # Salva o GeoDataFrame resultante no novo shapefile
                gdf_selecionado.to_file(shapefile_saida, driver='ESRI Shapefile')
            except:
                pass

        def obter_camadas_de_pontos():
            # Obtém a lista de camadas no projeto
            camadas = QgsProject.instance().mapLayers().values()

            # Filtra apenas as camadas de pontos
            camadas_de_pontos = [camada for camada in camadas if camada.type() == QgsMapLayerType.VectorLayer and camada.geometryType() == QgsWkbTypes.PointGeometry]
        
            return camadas_de_pontos
        
        def recortar_e_carregar_camadas():
            lista_perfil = obter_camadas_de_pontos()
            for p in lista_perfil:
                recortar = processing.run('native:clip', {
                    'INPUT': p,
                    'OVERLAY': 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp',
                    'OUTPUT': os.path.join('C:/geoprocessamento/PROCESSAMENTO/point', f'{p.name()}_parcial.shp')
                })
                
                output_recorte = recortar['OUTPUT']
                
                # Criar um objeto QgsVectorLayer a partir do caminho do arquivo
                layer_recortada = QgsVectorLayer(output_recorte, f'{p.name()}_parcial', 'ogr')
                
                # Verificar se a camada foi carregada corretamente
                if layer_recortada.isValid():
                    QgsProject.instance().addMapLayer(layer_recortada)
                else:
                    print(f"Erro ao carregar a camada recortada: {layer_recortada.dataProvider().error().message()}")
        
        def BufferShapefile():
            # Lê o shapefile de entrada
            gdf = gpd.read_file('C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')

            # Converte a distância de metros para graus (WGS84)
            buffer_distance_degrees = 1 / 111320  # Aproximadamente 111320 metros por grau

            # Aplica o buffer ao GeoDataFrame
            gdf['geometry'] = gdf['geometry'].buffer(buffer_distance_degrees)

            # Salva o novo shapefile com o buffer
            gdf.to_file('C:/geoprocessamento/PROCESSAMENTO/poligono/co_buffer.shp')
    
        exportar_features_selecionadas(caminho_saida = 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')
        SelecionarCampos(['CLIENTE', 'FAZENDA', 'TALHAO', 'BLOCO','GRID', 'HECTARES'], 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')  
        recortar_e_carregar_camadas()
        BufferShapefile()
       
    def PrepararCSVeDAT(self):
        
        padrao_processamento = self.dlg.comboBoxPadrao.currentText()
        
        key_list_full =  ["ARGILA1", "ARGILA2", "MO1", "MO2", "MO3", "PH1", "PH2", "PH3", 
        "CTC1", "CTC2", "CTC3", "CTC4", "CTC5", "CTC6", "CTC7", 
        "V1", "V2", "V3", "V4", "V5", "V6", "V7", 
        "CA1", "CA2", "CA3", "CA4", "CA5", "CA6", "CA7", 
        "SAT_CA1", "SAT_CA2", "SAT_CA3", "SAT_CA4", "SAT_CA5", "SAT_CA6", "SAT_CA7"
        "MG1", "MG2", "MG3", 
        "SAT_MG1", "SAT_MG2", "SAT_MG3", 
        "REL_CA_MG1", "REL_CA_MG2", "REL_CA_MG3", 
        "K1", "K2", "K3", 
        "SAT_K1", "SAT_K2", "SAT_K3", 
        "P_MEH1", "P_MEH2", "P_MEH3", 
        "P_REM1", "P_REM2", "P_REM3", 
        "P_RES1", "P_RES2", "P_RES3", 
        "AL1", "AL2", "AL3", "AL4", "AL5", "AL6", "AL7", 
        "SAT_AL1", "SAT_AL2", "SAT_AL3", 
        "S1", "S2", "S3", "S4", "S5", "S6", "S7", 
        "B1", "B2", "B3", 
        "CU1", "CU2", "CU3", 
        "FE1", "FE2", "FE3", 
        "MN1", "MN2", "MN3", 
        "ZN1", "ZN2", "ZN3"
        ]

        key_list_padrao_terram = [
                "ARGILA1", "ARGILA2", "MO1", "MO2", "MO3", "PH1", "PH2", "PH3", 
                "CTC1", "CTC2", "CTC3", "CTC4", "CTC5", "CTC6", "CTC7", 
                "V1", "V2", "V3", "V4", "V5", "V6", "V7", 
                "CA1", "CA2", "CA3", "CA4", "CA5", "CA6", "CA7", 
                "SAT_CA1", "SAT_CA2", "SAT_CA3", 
                "MG1", "MG2", "MG3", 
                "SAT_MG1", "SAT_MG2", "SAT_MG3", 
                "REL_CA_MG1", "REL_CA_MG2", "REL_CA_MG3", 
                "K1", "K2", "K3", 
                "SAT_K1", "SAT_K2", "SAT_K3", 
                "P_MEH1", "P_MEH2", "P_MEH3", 
                "P_REM1", "P_REM2", "P_REM3", 
                "P_RES1", "P_RES2", "P_RES3", 
                "AL1", "AL2", "AL3", "AL4", "AL5", "AL6", "AL7", 
                "SAT_AL1", "SAT_AL2", "SAT_AL3", 
                "S1", "S2", "S3", "S4", "S5", "S6", "S7", 
                "B1", "B2", "B3", 
                "CU1", "CU2", "CU3", 
                "FE1", "FE2", "FE3", 
                "MN1", "MN2", "MN3", 
                "ZN1", "ZN2", "ZN3"
            ]

        key_list_elo =  ["ARGILA1", "ARGILA2", "MO1", "MO2", "MO3", "PH1", "PH2", "PH3", 
                "CTC1", "CTC2", "CTC3", "CTC4", "CTC5", "CTC6", "CTC7", 
                "V1", "V2", "V3", "V4", "V5", "V6", "V7", 
                "CA1", "CA2", "CA3", "CA4", "CA5", "CA6", "CA7", 
                "SAT_CA1", "SAT_CA2", "SAT_CA3", "SAT_CA4", "SAT_CA5", "SAT_CA6", "SAT_CA7"
                "MG1", "MG2", "MG3", 
                "SAT_MG1", "SAT_MG2", "SAT_MG3", 
                "REL_CA_MG1", "REL_CA_MG2", "REL_CA_MG3", 
                "K1", "K2", "K3", 
                "SAT_K1", "SAT_K2", "SAT_K3", 
                "P_MEH1", "P_MEH2", "P_MEH3", 
                "P_REM1", "P_REM2", "P_REM3", 
                "P_RES1", "P_RES2", "P_RES3", 
                "AL1", "AL2", "AL3", "AL4", "AL5", "AL6", "AL7", 
                "SAT_AL1", "SAT_AL2", "SAT_AL3", 
                "S1", "S2", "S3", "S4", "S5", "S6", "S7", 
                "B1", "B2", "B3", 
                "CU1", "CU2", "CU3", 
                "FE1", "FE2", "FE3", 
                "MN1", "MN2", "MN3", 
                "ZN1", "ZN2", "ZN3"
            ]
        
        if padrao_processamento == 'Terram':
            key_list_processamento = key_list_padrao_terram
        
        if padrao_processamento == 'ELO':
            key_list_processamento = key_list_elo 
        
        if padrao_processamento == 'Completo':
            key_list_processamento = key_list_full
        
        def Add_Coordenadas_OrganizarDataFrame_Dentro_Da_Pasta():
            folder_path = 'C:/geoprocessamento/PROCESSAMENTO/point/' 
            # Lista todos os arquivos na pasta com a extensão .shp
            shapefile_paths = [os.path.join(folder_path, file) for file in os.listdir(folder_path) if file.endswith('.shp')]

            # Lista para armazenar os DataFrames organizados
            organized_gdfs = []

            for shapefile_path in shapefile_paths:
                gdf = gpd.read_file(shapefile_path)

                # Verifica se o shapefile contém as colunas 'geometry'
                if 'geometry' in gdf.columns:
                    # Extrai as coordenadas X e Y em colunas separadas
                    gdf['X'] = gdf['geometry'].x
                    gdf['Y'] = gdf['geometry'].y

                    # Converte os nomes das colunas para maiúsculas
                    gdf.columns = map(str.upper, gdf.columns)

                    # Reorganiza as colunas do DataFrame
                    gdf = gdf[['X', 'Y'] + [col for col in gdf.columns if col not in ['X', 'Y']]]

                    organized_gdfs.append(gdf)
                else:
                    print(f"O shapefile {shapefile_path} não contém a coluna 'geometry'.")

            return organized_gdfs
            
        def Remove_Columns_Change_Value_Equal(gdf, columns_to_remove=None):
            if columns_to_remove is None:
                columns_to_remove = ['ID', 'LAB', 'LOTE', 'PROF', 'GEOMETRY']

            # Remove the specified columns
            gdf = gdf.drop(columns=columns_to_remove)

            for coluna in gdf.columns:
                if gdf[coluna].nunique() == 1:
                    # If all values in the column are equal
                    # Choose a random index to add the value
                    indice_aleatorio = random.randint(0, len(gdf) - 1)
                    gdf.at[indice_aleatorio, coluna] += 0.00000000000001

            return gdf
            
        def Exportar_Csv_Todos_Atributos(gdf, output_folder):
            # Garante que o diretório de saída existe
            os.makedirs(output_folder, exist_ok=True)

            # Obtém uma lista de todas as colunas, exceto 'X' e 'Y'
            columns_to_export = [col for col in gdf.columns if col not in ['X', 'Y']]

            # Itera sobre as colunas a serem exportadas
            for column in columns_to_export:
                # Verifica se algum valor na coluna está vazio
                if gdf[column].notna().any():
                    # Se algum valor não estiver vazio, crie o arquivo CSV
                    # Cria o nome do arquivo CSV com base no nome da coluna
                    csv_filename = f"{column}.csv"
                    csv_path = os.path.join(output_folder, csv_filename)

                    # Seleciona as colunas 'X', 'Y' e a coluna atual
                    selected_data = gdf[['X', 'Y', column]]

                    # Exporta os dados para o arquivo CSV
                    selected_data.to_csv(csv_path, index=False)

        def Exportar_Csv_Em_Loop():
            for idx, cleaned_gdf in enumerate(cleaned_gdfs):
                Exportar_Csv_Todos_Atributos(cleaned_gdf, output_folder = 'C:/geoprocessamento/PROCESSAMENTO/saida/' )
                
        def Remover_Csv_Que_Nao_Ira_Processar(keys_list):
            caminho_pasta = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            # Lista todos os arquivos na pasta
            arquivos_na_pasta = os.listdir(caminho_pasta)

            # Filtra apenas os arquivos CSV
            arquivos_csv = [arquivo for arquivo in arquivos_na_pasta if arquivo.endswith('.csv')]

            # Identifica os arquivos a serem removidos
            arquivos_a_remover = [arquivo for arquivo in arquivos_csv if arquivo[:-4] not in keys_list]

            # Remove os arquivos indesejados
            for arquivo in arquivos_a_remover:
                caminho_arquivo = os.path.join(caminho_pasta, arquivo)
                os.remove(caminho_arquivo)
                print(f"Arquivo removido: {arquivo}")

        def Renomear_Csv_Padrao_Terram():
            directory = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            name_mapping = {
            "ARGILA1": "Argila1 0-20 cm",
            "ARGILA2": "Argila2 0-10 cm",
            "ARGILA3": "Argila3 10-20 cm",
            "ARGILA4": "Argila4 20-40 cm",
            "MO1": "Mo1 0-20 cm",
            "MO2": "Mo2 0-10 cm",
            "MO3": "Mo3 10-20 cm",
            "MO4": "Mo4 20-40 cm",
            "PH1": "pH1 0-20 cm",
            "PH2": "pH2 0-10 cm",
            "PH3": "pH3 10-20 cm",
            "PH4": "pH4 20-40 cm",
            "CTC1": "CTC1 0-20 cm",
            "CTC2": "CTC2 0-10 cm",
            "CTC3": "CTC3 10-20 cm",
            "CTC4": "CTC4 20-40 cm",
            "CTC5": "CTC5 40-60 cm",
            "CTC6": "CTC6 60-80 cm",
            "CTC7": "CTC7 80-100 cm",
            "V1": "V1 0-20 cm",
            "V2": "V2 0-10 cm",
            "V3": "V3 10-20 cm",
            "V4": "V4 20-40 cm",
            "V5": "V5 40-60 cm",
            "V6": "V6 60-80 cm",
            "V7": "V7 80-100 cm",
            "CA1": "Ca1 0-20 cm",
            "CA2": "Ca2 0-10 cm",
            "CA3": "Ca3 10-20 cm",
            "CA4": "Ca4 20-40 cm",
            "CA5": "Ca5 40-60 cm",
            "CA6": "Ca6 60-80 cm",
            "CA7": "Ca7 80-100 cm",
            "SAT_CA1": "Sat_Ca1 0-20 cm",
            "SAT_CA2": "Sat_Ca2 0-10 cm",
            "SAT_CA3": "Sat_Ca3 10-20 cm",
            "SAT_CA4": "Sat_Ca4 20-40 cm",
            "MG1": "Mg1 0-20 cm",
            "MG2": "Mg2 0-10 cm",
            "MG3": "Mg3 10-20 cm",
            "MG4": "Mg4 20-40 cm",
            "SAT_MG1": "Sat_Mg1 0-20 cm",
            "SAT_MG2": "Sat_Mg2 0-10 cm",
            "SAT_MG3": "Sat_Mg3 10-20 cm",
            "SAT_MG4": "Sat_Mg4 20-40 cm",
            "REL_CA_MG1": "Rel_Ca_Mg1 0-20 cm",
            "REL_CA_MG2": "Rel_Ca_Mg2 0-10 cm",
            "REL_CA_MG3": "Rel_Ca_Mg3 10-20 cm",
            "REL_CA_MG4": "Rel_Ca_Mg4 20-40 cm",
            "K1": "K1 0-20 cm",
            "K2": "K2 0-10 cm",
            "K3": "K3 10-20 cm",
            "K4": "K4 20-40 cm",
            "SAT_K1": "Sat_K1 0-20 cm",
            "SAT_K2": "Sat_K2 0-10 cm",
            "SAT_K3": "Sat_K3 10-20 cm",
            "SAT_K4": "Sat_K4 20-40 cm",
            "P_MEH1": "P_meh1 0-20 cm",
            "P_MEH2": "P_meh2 0-10 cm",
            "P_MEH3": "P_meh3 10-20 cm",
            "P_MEH4": "P_meh4 20-40 cm",
            "P_REM1": "P_rem1 0-20 cm",
            "P_REM2": "P_rem2 0-10 cm",
            "P_REM3": "P_rem3 10-20 cm",
            "P_REM4": "P_rem4 20-40 cm",
            "P_RES1": "P_res1 0-20 cm",
            "P_RES2": "P_res2 0-10 cm",
            "P_RES3": "P_res3 10-20 cm",
            "P_RES4": "P_res4 20-40 cm",
            "AL1": "Al1 0-20 cm",
            "AL2": "Al2 0-10 cm",
            "AL3": "Al3 10-20 cm",
            "AL4": "Al4 20-40 cm",
            "AL5": "Al5 40-60 cm",
            "AL6": "Al6 60-80 cm",
            "AL7": "Al7 80-100 cm",
            "SAT_AL1": "Sat_Al1 0-20 cm",
            "SAT_AL2": "Sat_Al2 0-10 cm",
            "SAT_AL3": "Sat_Al3 10-20 cm",
            "SAT_AL4": "Sat_Al4 20-40 cm",
            "S1": "S1 0-20 cm",
            "S2": "S2 0-10 cm",
            "S3": "S3 10-20 cm",
            "S4": "S4 20-40 cm",
            "S5": "S5 40-60 cm",
            "S6": "S6 60-80 cm",
            "S7": "S7 80-100 cm",
            "B1": "B1 0-20 cm",
            "B2": "B2 0-10 cm",
            "B3": "B3 10-20 cm",
            "B4": "B4 20-40 cm",
            "CU1": "Cu1 0-20 cm",
            "CU2": "Cu2 0-10 cm",
            "CU3": "Cu3 10-20 cm",
            "CU4": "Cu4 20-40 cm",
            "FE1": "Fe1 0-20 cm",
            "FE2": "Fe2 0-10 cm",
            "FE3": "Fe3 10-20 cm",
            "FE4": "Fe4 20-40 cm",
            "MN1": "Mn1 0-20 cm",
            "MN2": "Mn2 0-10 cm",
            "MN3": "Mn3 10-20 cm",
            "MN4": "Mn4 20-40 cm",
            "ZN1": "Zn1 0-20 cm",
            "ZN2": "Zn2 0-10 cm",
            "ZN3": "Zn3 10-20 cm",
            "ZN4": "Zn4 20-40 cm"
        }
            
            for filename in os.listdir(directory):
                if filename.endswith(".csv"):
                    old_path = os.path.join(directory, filename)
                    
                    # Extracting the key from the filename
                    key = filename.split(".")[0].upper()
                    
                    # Checking if the key exists in the mapping
                    if key in name_mapping:
                        new_filename = name_mapping[key] + "." + filename.split(".", 1)[1]
                        new_path = os.path.join(directory, new_filename)
                        
                        # Renaming the file
                        os.rename(old_path, new_path)
                        print(f"Renamed: {filename} -> {new_filename}")
                    else:
                        print(f"Key not found in mapping: {key} for file {filename}")

        def Csv_To_Dat():
            input_folder = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            output_folder = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            # Verifique se as pastas de entrada e saída existem, e se não, crie-as
            if not os.path.exists(output_folder):
                os.makedirs(output_folder)

            # Lista de arquivos na pasta de entrada
            csv_files = [f for f in os.listdir(input_folder) if f.endswith('.csv')]

            for csv_file in csv_files:
                # Crie o caminho completo para o arquivo de entrada
                input_path = os.path.join(input_folder, csv_file)

                # Leia o arquivo CSV em um DataFrame do pandas
                df = pd.read_csv(input_path)

                # Crie o nome do arquivo de saída com a extensão .dat
                dat_file = os.path.splitext(csv_file)[0] + '.dat'

                # Crie o caminho completo para o arquivo de saída
                output_path = os.path.join(output_folder, dat_file)

                # Salve o DataFrame no arquivo .dat usando um delimitador de sua escolha (por exemplo, espaço)
                df.to_csv(output_path, sep=' ', index=False)
       
        organized_gdfs = Add_Coordenadas_OrganizarDataFrame_Dentro_Da_Pasta()
        cleaned_gdfs = [Remove_Columns_Change_Value_Equal(gdf) for gdf in organized_gdfs]
        Exportar_Csv_Em_Loop()  
        Remover_Csv_Que_Nao_Ira_Processar(keys_list = key_list_processamento) 
        Renomear_Csv_Padrao_Terram()
        Csv_To_Dat()
    
    def PrepararParametrosBas(self):
        import re
        import math
        pixel_tamanho = self.dlg.mQgsSpinBoxPixel.value()
        def GetLimitsShapefile():
        # Lê o arquivo Shapefile
            gdf = gpd.read_file("C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp")
            
            # Calcula os limites
            xmin, ymin, xmax, ymax = gdf.total_bounds
            
            return xmin, xmax, ymin, ymax

        xmin, xmax, ymin, ymax = GetLimitsShapefile()
    
    

        def CalculateNumColumnsRows(xmin, xmax, ymin, ymax, cell_size_meters):
            # Calcula a largura e a altura da área em graus
            largura_graus = xmax - xmin
            altura_graus = ymax - ymin

            # Converte o tamanho da célula de metros para graus
            cell_size_meters = cell_size_meters / (111320.0)  # Aproximadamente 111320 metros por grau de latitude

            # Calcula o número de colunas e linhas
            numCols = math.ceil(largura_graus / cell_size_meters)
            numRows = math.ceil(altura_graus / cell_size_meters)

            return numCols, numRows


        numCols, numRows = CalculateNumColumnsRows(xmin, xmax, ymin, ymax, cell_size_meters = pixel_tamanho)
    
        def UpdateBasWithBounds(bas_file_path, xmin, ymin, xmax, ymax, numCols, numRows):

            # Abra o arquivo VBA para leitura
            with open(bas_file_path) as file:
                bas_code = file.read()

            # Use expressões regulares para encontrar e substituir os valores
            bas_code = re.sub(r'xMin:=', f'xMin:={xmin}', bas_code)
            bas_code = re.sub(r'xMax:=', f'xMax:={xmax}', bas_code)
            bas_code = re.sub(r'yMin:=', f'yMin:={ymin}', bas_code)
            bas_code = re.sub(r'yMax:=', f'yMax:={ymax}', bas_code)
            bas_code = re.sub(r'numRows:=', f'numRows:={numRows}', bas_code)
            bas_code = re.sub(r'numCols:=', f'numCols:={numCols}', bas_code)

            # Salve o arquivo VBA atualizado com um novo nome "krig.bas"
            new_bas_file_path = 'C:/geoprocessamento/PROCESSAMENTO/bas/krig.bas'
            with open(new_bas_file_path, 'w') as file:
                file.write(bas_code)

            print("Valores atualizados no arquivo VBA e salvo como krig.bas.")

        # Exemplo de uso da função:
        bas_file_path = 'C:/geoprocessamento/PROCESSAMENTO/bas/model.bas'


        UpdateBasWithBounds(bas_file_path, xmin, ymin, xmax, ymax, numCols, numRows)

    def ExcutarSubProcessoSurfer8(self):
        
        import subprocess

        # Caminho para o Surfer Scripter.exe
        scripter_exe = r'C:\Program Files (x86)\Golden Software\Surfer8\Scripter\Scripter.exe'

        # Caminho para o arquivo de script VBA
        vba_script_file = r'C:\geoprocessamento\PROCESSAMENTO\bas\krig.bas'  # Substitua pelo caminho do seu arquivo VBA

        # Comando para executar o Surfer Scripter com o script VBA como entrada
        command = f'"{scripter_exe}" -x "{vba_script_file}"'  # Adicione o -x entre as aspas duplas

        try:
            process = subprocess.Popen(command, shell=True)
            process.wait()  # Aguarda a conclusão do processo
            print("Script VBA executado com sucesso no Surfer.")
            process.terminate()  # Encerra o processo
        except subprocess.CalledProcessError as e:
            print(f"Erro ao executar o script BAS: {e}")
        except FileNotFoundError as e:
            print(f"Arquivo do Surfer Scripter não encontrado: {e}")
              
    def PrepararShapefileRecApresentacao(self):
    
        import os
        import geopandas as gpd
        from shapely.geometry import box
        import glob
        from decimal import Decimal, ROUND_DOWN
        import shutil
        import rasterio
        from rasterio.features import shapes
               
        def PixelToPolygon(pasta_de_entrada, pasta_de_saida, dtype='float32'):
            # Listar os arquivos .grd na pasta de entrada
            arquivos_grd = [arquivo for arquivo in os.listdir(pasta_de_entrada) if arquivo.endswith('.grd')]

            for arquivo in arquivos_grd:
                # Abrir o arquivo .grd usando rasterio
                arquivo_grd = os.path.join(pasta_de_entrada, arquivo)
                with rasterio.open(arquivo_grd) as src:
                    # Ler os valores da banda
                    values = src.read(1)

                    # Converter os valores para o tipo de dados especificado
                    if dtype == 'int16':
                        values = values.astype('int16')
                    elif dtype == 'int32':
                        values = values.astype('int32')
                    elif dtype == 'uint8':
                        values = values.astype('uint8')
                    elif dtype == 'uint16':
                        values = values.astype('uint16')
                    elif dtype == 'float32':
                        values = values.astype('float32')

                    # Criar polígonos a partir dos pixels
                    polygons = list(
                        {'properties': {'value': v}, 'geometry': s}
                        for i, (s, v) in enumerate(shapes(values, mask=None, transform=src.transform))
                    )

                    # Criar um GeoDataFrame
                    gdf = gpd.GeoDataFrame.from_features(polygons)

                    # Salvar o GeoDataFrame em um shapefile
                    nome_sem_extensao = os.path.splitext(arquivo)[0]
                    nome_shapefile = os.path.join(pasta_de_saida, f"{nome_sem_extensao}.shp")
                    gdf.to_file(nome_shapefile)

        # Exemplo de uso:
        pasta_de_entrada = "C:/geoprocessamento/PROCESSAMENTO/saida/"
        pasta_de_saida = "C:/geoprocessamento/PROCESSAMENTO/saida/"
        dtype = 'float32'  # Especifique o tipo de dados apropriado aqui
        PixelToPolygon(pasta_de_entrada, pasta_de_saida, dtype)
    
        def AtualizarNomeCampos(folder_path):
            field_mapping = {
            "Argila1 0-20 cm": "ARGILA1",
            "Argila2 0-10 cm": "ARGILA2",
            "Argila3 10-20 cm": "ARGILA3",
            "Argila4 20-40 cm": "ARGILA4",
            "Mo1 0-20 cm": "MO1",
            "Mo2 0-10 cm": "MO2",
            "Mo3 10-20 cm": "MO3",
            "Mo4 20-40 cm": "MO4",
            "pH1 0-20 cm": "PH1",
            "pH2 0-10 cm": "PH2",
            "pH3 10-20 cm": "PH3",
            "pH4 20-40 cm": "PH4",
            "CTC1 0-20 cm": "CTC1",
            "CTC2 0-10 cm": "CTC2",
            "CTC3 10-20 cm": "CTC3",
            "CTC4 20-40 cm": "CTC4",
            "CTC5 40-60 cm": "CTC5",
            "CTC6 60-80 cm": "CTC6",
            "CTC7 80-100 cm": "CTC7",
            "V1 0-20 cm": "V1",
            "V2 0-10 cm": "V2",
            "V3 10-20 cm": "V3",
            "V4 20-40 cm": "V4",
            "V5 40-60 cm": "V5",
            "V6 60-80 cm": "V6",
            "V7 80-100 cm": "V7",
            "Ca1 0-20 cm": "CA1",
            "Ca2 0-10 cm": "CA2",
            "Ca3 10-20 cm": "CA3",
            "Ca4 20-40 cm": "CA4",
            "Ca5 40-60 cm": "CA5",
            "Ca6 60-80 cm": "CA6",
            "Ca7 80-100 cm": "CA7",
            "Sat_Ca1 0-20 cm": "SAT_CA1",
            "Sat_Ca2 0-10 cm": "SAT_CA2",
            "Sat_Ca3 10-20 cm": "SAT_CA3",
            "Sat_Ca4 20-40 cm": "SAT_CA4",
            "Mg1 0-20 cm": "MG1",
            "Mg2 0-10 cm": "MG2",
            "Mg3 10-20 cm": "MG3",
            "Mg4 20-40 cm": "MG4",
            "Sat_Mg1 0-20 cm": "SAT_MG1",
            "Sat_Mg2 0-10 cm": "SAT_MG2",
            "Sat_Mg3 10-20 cm": "SAT_MG3",
            "Sat_Mg4 20-40 cm": "SAT_MG4",
            "Rel_Ca_Mg1 0-20 cm": "REL_CA_MG1",
            "Rel_Ca_Mg2 0-10 cm": "REL_CA_MG2",
            "Rel_Ca_Mg3 10-20 cm": "REL_CA_MG3",
            "Rel_Ca_Mg4 20-40 cm": "REL_CA_MG4",
            "K1 0-20 cm": "K1",
            "K2 0-10 cm": "K2",
            "K3 10-20 cm": "K3",
            "K4 20-40 cm": "K4",
            "Sat_K1 0-20 cm": "SAT_K1",
            "Sat_K2 0-10 cm": "SAT_K2",
            "Sat_K3 10-20 cm": "SAT_K3",
            "Sat_K4 20-40 cm": "SAT_K4",
            "P_meh1 0-20 cm": "P_MEH1",
            "P_meh2 0-10 cm": "P_MEH2",
            "P_meh3 10-20 cm": "P_MEH3",
            "P_meh4 20-40 cm": "P_MEH4",
            "P_rem1 0-20 cm": "P_REM1",
            "P_rem2 0-10 cm": "P_REM2",
            "P_rem3 10-20 cm": "P_REM3",
            "P_rem4 20-40 cm": "P_REM4",
            "P_res1 0-20 cm": "P_RES1",
            "P_res2 0-10 cm": "P_RES2",
            "P_res3 10-20 cm": "P_RES3",
            "P_res4 20-40 cm": "P_RES4",
            "Al1 0-20 cm": "AL1",
            "Al2 0-10 cm": "AL2",
            "Al3 10-20 cm": "AL3",
            "Al4 20-40 cm": "AL4",
            "Al5 40-60 cm": "AL5",
            "Al6 60-80 cm": "AL6",
            "Al7 80-100 cm": "AL7",
            "Sat_Al1 0-20 cm": "SAT_AL1",
            "Sat_Al2 0-10 cm": "SAT_AL2",
            "Sat_Al3 10-20 cm": "SAT_AL3",
            "Sat_Al4 20-40 cm": "SAT_AL4",
            "S1 0-20 cm": "S1",
            "S2 0-10 cm": "S2",
            "S3 10-20 cm": "S3",
            "S4 20-40 cm": "S4",
            "S5 40-60 cm": "S5",
            "S6 60-80 cm": "S6",
            "S7 80-100 cm": "S7",
            "B1 0-20 cm": "B1",
            "B2 0-10 cm": "B2",
            "B3 10-20 cm": "B3",
            "B4 20-40 cm": "B4",
            "Cu1 0-20 cm": "CU1",
            "Cu2 0-10 cm": "CU2",
            "Cu3 10-20 cm": "CU3",
            "Cu4 20-40 cm": "CU4",
            "Fe1 0-20 cm": "FE1",
            "Fe2 0-10 cm": "FE2",
            "Fe3 10-20 cm": "FE3",
            "Fe4 20-40 cm": "FE4",
            "Mn1 0-20 cm": "MN1",
            "Mn2 0-10 cm": "MN2",
            "Mn3 10-20 cm": "MN3",
            "Mn4 20-40 cm": "MN4",
            "Zn1 0-20 cm": "ZN1",
            "Zn2 0-10 cm": "ZN2",
            "Zn3 10-20 cm": "ZN3",
            "Zn4 20-40 cm": "ZN4"
            }
            # Lista todos os arquivos na pasta
            shapefiles = [f for f in os.listdir(folder_path) if f.endswith(".shp")]

            # Itera sobre os arquivos na pasta
            for shapefile in shapefiles:
                shapefile_path = os.path.join(folder_path, shapefile)

                # Carregue o shapefile usando o GeoPandas
                gdf = gpd.read_file(shapefile_path)

                # Obtenha o nome do arquivo sem a extensão
                file_name = os.path.splitext(shapefile)[0]

                # Verifique se o nome do arquivo existe no mapeamento
                if file_name in field_mapping:
                    new_field_name = field_mapping[file_name]

                    # Renomeia a coluna 'value' para o novo nome do campo
                    gdf = gdf.rename(columns={'value': new_field_name})

                    # Salva o GeoDataFrame de volta como um shapefile
                    output_path = os.path.join(folder_path, shapefile)
                    gdf.to_file(output_path)

                else:
                    print(f"Aviso: O arquivo '{file_name}' não está no mapeamento. Nenhuma ação foi realizada para este arquivo.")

        # Exemplo de uso da função com o dicionário fornecido
        folder_path = "C:/geoprocessamento/PROCESSAMENTO/saida/"
        AtualizarNomeCampos(folder_path)

        def RecortarShapefiles(pasta_saida, pasta_poligono, pasta_recorte, rec=False):
            # Carregar o polígono de sobreposição
            poligono = gpd.read_file(pasta_poligono)

            # Listar todos os arquivos na pasta de saída
            arquivos_saida = glob.glob(os.path.join(pasta_saida, '*.shp'))

            for arquivo_saida in arquivos_saida:
                # Carregar o shapefile de saída
                shapefile_saida = gpd.read_file(arquivo_saida)

                # Definir o nome do arquivo padrão
                nome_arquivo = os.path.basename(arquivo_saida)

                # Verificar se o parâmetro rec está ativado
                if rec:
                    # Verificar se o arquivo atende aos critérios de recorte
                    if any(nome_arquivo.startswith(prefixo) for prefixo in [
                        'CTC1', 'CTC2', 'CTC3', 'CTC4', 'CTC5', 'CTC6', 'CTC6','CTC7',
                        'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V5','V6','V7',
                        'Ca1', 'Ca2', 'Ca3', 'Ca4', 'Ca4', 'Ca5', 'Ca6','Ca7',
                        'Sat_Ca1', 'Sat_Ca2', 'Sat_Ca3',
                        'Mg1', 'Mg2', 'Mg3', 'Sat_Mg1','Sat_Mg2', 'Sat_Mg3',
                        'K1', 'K2', 'K3',
                        'P_res1', 'P_res2', 'P_res3',
                        'Al4', 'Al5', 'Al6','Al7',
                        'S4', 'S5', 'S6','S7'
                    ]):
                        # Realizar o recorte usando a sobreposição
                        recorte = gpd.overlay(shapefile_saida, poligono, how='intersection')

                        # Salvar o recorte na pasta de recorte
                        caminho_recorte = os.path.join(pasta_recorte, nome_arquivo)
                        recorte.to_file(caminho_recorte, driver='ESRI Shapefile')
                else:
                    # Realizar o recorte usando a sobreposição
                    recorte = gpd.overlay(shapefile_saida, poligono, how='intersection')

                    # Salvar o recorte na pasta de recorte
                    caminho_recorte = os.path.join(pasta_recorte, nome_arquivo)
                    recorte.to_file(caminho_recorte, driver='ESRI Shapefile')

                # Substitua 'saida/', 'poligono/co_1.shp' e 'rec/' pelos caminhos corretos


        RecortarShapefiles('C:/geoprocessamento/PROCESSAMENTO/saida/', 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp', 'C:/geoprocessamento/PROCESSAMENTO/apresentacao/', rec=False)
        RecortarShapefiles('C:/geoprocessamento/PROCESSAMENTO/saida/', 'C:/geoprocessamento/PROCESSAMENTO/poligono/co_buffer.shp', 'C:/geoprocessamento/PROCESSAMENTO/rec/', rec=True)
    
        def AjusteGeoDataframe(pasta_list):
            for pasta in pasta_list:
                for filename in os.listdir(pasta):
                    if filename.endswith(".shp"):
                        file_path = os.path.join(pasta, filename)
                        
                        # Carrega o GeoDataFrame a partir do arquivo shape
                        gdf = gpd.read_file(file_path)


                        # Define como 0 os valores negativos na primeira coluna
                        gdf[gdf.columns[0]] = gdf[gdf.columns[0]].apply(lambda x: max(0, x))

                        # # Adiciona um campo ID com incremento automático
                        gdf['ID'] = range(1, len(gdf) + 1)


                        # Salva o GeoDataFrame processado no mesmo arquivo shape
                        gdf.to_file(file_path)

            return f"Processamento concluído para todos os arquivos em {', '.join(pasta_list)}"

        # Processa os arquivos shape nas pastas "rec/" e "apresentacao/"
        pastas = ["C:/geoprocessamento/PROCESSAMENTO/rec/", "C:/geoprocessamento/PROCESSAMENTO/apresentacao/"]
        try:
            AjusteGeoDataframe(pastas)
        except:
            pass
    
        def merge_shapefiles(input_folder, output_folder, output_filename):
            # Listar todos os arquivos shapefile na pasta de entrada
            shapefiles = [f for f in os.listdir(input_folder) if f.endswith('.shp')]

            # Verificar se há pelo menos dois shapefiles para mesclar
            if len(shapefiles) < 2:
                print("Pelo menos dois shapefiles são necessários para mesclar.")
                return

            # Ler o primeiro shapefile
            first_shapefile = os.path.join(input_folder, shapefiles[0])
            gdf_merged = gpd.read_file(first_shapefile)

            # Loop sobre os shapefiles restantes e adicionar colunas ausentes
            for shapefile in shapefiles[1:]:
                shapefile_path = os.path.join(input_folder, shapefile)
                gdf_to_merge = gpd.read_file(shapefile_path)

                # Adicionar colunas ausentes
                columns_to_add = [col for col in gdf_to_merge.columns if col not in gdf_merged.columns and col != 'geometry']
                for col in columns_to_add:
                    gdf_merged[col] = gdf_to_merge[col]

            # Exportar o resultado para um novo shapefile
            output_path = os.path.join(output_folder, output_filename)
            gdf_merged.to_file(output_path, driver='ESRI Shapefile')

            print(f"A junção foi concluída com sucesso. O arquivo {output_filename} foi criado em {output_folder}.")

        # Exemplo de uso:
        input_folder = 'C:/geoprocessamento/PROCESSAMENTO/rec/'
        output_folder = 'C:/geoprocessamento/PROCESSAMENTO/FileQgis/'
        output_filename = 'rec.shp'
        try:
            merge_shapefiles(input_folder, output_folder, output_filename)
        except:
            pass
    
        def OrganizarAtributos(input_shapefile, output_shapefile):
            # Ler o shapefile
            gdf = gpd.read_file(input_shapefile)


            # Reordenar colunas
            order_columns = ['ID', 'CLIENTE', 'FAZENDA', 'BLOCO','TALHAO', 'GRID'] + sorted([col for col in gdf.columns if col not in ['ID', 'CLIENTE', 'FAZENDA', 'BLOCO','TALHAO', 'GRID']])
            gdf = gdf[order_columns]

            # Exportar o resultado para um novo shapefile
            gdf.to_file(output_shapefile, driver='ESRI Shapefile')
            

            print(f"Arredondamento e reordenação concluídos com sucesso. O arquivo {output_shapefile} foi criado.")

        # Exemplo de uso:
        input_shapefile = 'C:/geoprocessamento/PROCESSAMENTO/FileQgis/rec.shp'
        output_shapefile = 'C:/geoprocessamento/PROCESSAMENTO/FileQgis/rec.shp'
        try:
            OrganizarAtributos(input_shapefile, output_shapefile)
        except:
            pass

        def copy_to_qgis_folder(source_folder, qgis_folder):
            # Verificar se o diretório de origem existe
            if not os.path.exists(source_folder):
                print(f"O diretório de origem '{source_folder}' não existe.")
                return

            # Verificar se o diretório de destino existe
            if not os.path.exists(qgis_folder):
                print(f"O diretório de destino '{qgis_folder}' não existe.")
                return

            # Listar todos os arquivos na pasta de origem
            files_to_copy = [f for f in os.listdir(source_folder) if os.path.isfile(os.path.join(source_folder, f))]

            # Copiar os arquivos para a pasta do projeto do QGIS
            for file_to_copy in files_to_copy:
                source_path = os.path.join(source_folder, file_to_copy)
                destination_path = os.path.join(qgis_folder, file_to_copy)

                shutil.copy2(source_path, destination_path)
                print(f"Arquivo '{file_to_copy}' copiado para '{qgis_folder}'.")

            # Adicionar a cópia específica para arquivos relacionados ao prefixo 'co'
            prefix = 'co_original'
            source_poligono_folder = 'C:/geoprocessamento/PROCESSAMENTO/poligono/'
            for file in os.listdir(source_poligono_folder):
                if file.startswith(prefix):
                    source_file_path = os.path.join(source_poligono_folder, file)
                    destination_file_path = os.path.join(qgis_folder, file)
                    shutil.copy2(source_file_path, destination_file_path)
                    print(f"Arquivo '{file}' copiado para '{qgis_folder}'.")

        # Exemplo de uso:
        source_folder = 'C:/geoprocessamento/PROCESSAMENTO/apresentacao/'
        qgis_folder = 'C:/geoprocessamento/PROCESSAMENTO/FileQgis/'
        copy_to_qgis_folder(source_folder, qgis_folder)
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Processo Concluído")
        msg_box.setText("O processo foi finalizado com sucesso!")
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
    
    def PuxarLayoutELegagendas(self):
        from qgis.core import QgsProject, QgsVectorLayer
        from collections import OrderedDict
        import qgis.core
    
    
        field_mapping = OrderedDict({
        "rec": "v2",
        "Argila1 0-20 cm": "argila1",
        "Argila2 0-10 cm": "argila2",
        "Argila3 10-20 cm": "argila3",
        "Argila4 20-40 cm": "argila4",
        "Mo1 0-20 cm": "mo1",
        "Mo2 0-10 cm": "mo2",
        "Mo3 10-20 cm": "mo3",
        "Mo4 20-40 cm": "mo4",
        "CTC1 0-20 cm": "ctc1",
        "CTC2 0-10 cm": "ctc2",
        "CTC3 10-20 cm": "ctc3",
        "CTC4 20-40 cm": "ctc4",
        "CTC5 40-60 cm": "ctc5",
        "CTC6 60-80 cm": "ctc6",
        "CTC7 80-100 cm": "ctc7",
        "pH1 0-20 cm": "ph1",
        "pH2 0-10 cm": "ph2",
        "pH3 10-20 cm": "ph3",
        "pH4 20-40 cm": "ph4",
        "V1 0-20 cm": "v1",
        "V2 0-10 cm": "v2",
        "V3 10-20 cm": "v3",
        "V4 20-40 cm": "v4",
        "V5 40-60 cm": "v5",
        "V6 60-80 cm": "v6",
        "V7 80-100 cm": "v7",
        "Ca1 0-20 cm": "ca1",
        "Ca2 0-10 cm": "ca2",
        "Ca3 10-20 cm": "ca3",
        "Ca4 20-40 cm": "ca4",
        "Ca5 40-60 cm": "ca5",
        "Ca6 60-80 cm": "ca6",
        "Ca7 80-100 cm": "ca7",
        "Sat_Ca1 0-20 cm": "sat_ca1",
        "Sat_Ca2 0-10 cm": "sat_ca2",
        "Sat_Ca3 10-20 cm": "sat_ca3",
        "Sat_Ca4 20-40 cm": "sat_ca4",
        "Mg1 0-20 cm": "mg1",
        "Mg2 0-10 cm": "mg2",
        "Mg3 10-20 cm": "mg3",
        "Mg4 20-40 cm": "mg4",
        "Sat_Mg1 0-20 cm": "sat_mg1",
        "Sat_Mg2 0-10 cm": "sat_mg2",
        "Sat_Mg3 10-20 cm": "sat_mg3",
        "Sat_Mg4 20-40 cm": "sat_mg4",
        "Rel_Ca_Mg1 0-20 cm": "rel_ca_mg1",
        "Rel_Ca_Mg2 0-10 cm": "rel_ca_mg2",
        "Rel_Ca_Mg3 10-20 cm": "rel_ca_mg3",
        "Rel_Ca_Mg4 20-40 cm": "rel_ca_mg4",
        "K1 0-20 cm": "k1",
        "K2 0-10 cm": "k2",
        "K3 10-20 cm": "k3",
        "K4 20-40 cm": "k4",
        "Sat_K1 0-20 cm": "sat_k1",
        "Sat_K2 0-10 cm": "sat_k2",
        "Sat_K3 10-20 cm": "sat_k3",
        "Sat_K4 20-40 cm": "sat_k4",
        "P_meh1 0-20 cm": "p_meh1",
        "P_meh2 0-10 cm": "p_meh2",
        "P_meh3 10-20 cm": "p_meh3",
        "P_meh4 20-40 cm": "p_meh4",
        "P_rem1 0-20 cm": "p_rem1",
        "P_rem2 0-10 cm": "p_rem2",
        "P_rem3 10-20 cm": "p_rem3",
        "P_rem4 20-40 cm": "p_rem4",
        "P_res1 0-20 cm": "p_res1",
        "P_res2 0-10 cm": "p_res2",
        "P_res3 10-20 cm": "p_res3",
        "P_res4 20-40 cm": "p_res4",
        "Al1 0-20 cm": "al1",
        "Al2 0-10 cm": "al2",
        "Al3 10-20 cm": "al3",
        "Al4 20-40 cm": "al4",
        "Al5 40-60 cm": "al5",
        "Al6 60-80 cm": "al6",
        "Al7 80-100 cm": "al7",
        "Sat_Al1 0-20 cm": "sat_al1",
        "Sat_Al2 0-10 cm": "sat_al2",
        "Sat_Al3 10-20 cm": "sat_al3",
        "Sat_Al4 20-40 cm": "sat_al4",
        "S1 0-20 cm": "s1",
        "S2 0-10 cm": "s2",
        "S3 10-20 cm": "s3",
        "S4 20-40 cm": "s4",
        "S5 40-60 cm": "s5",
        "S6 60-80 cm": "s6",
        "S7 80-100 cm": "s7",
        "B1 0-20 cm": "b1",
        "B2 0-10 cm": "b2",
        "B3 10-20 cm": "b3",
        "B4 20-40 cm": "b4",
        "Cu1 0-20 cm": "cu1",
        "Cu2 0-10 cm": "cu2",
        "Cu3 10-20 cm": "cu3",
        "Cu4 20-40 cm": "cu4",
        "Fe1 0-20 cm": "fe1",
        "Fe2 0-10 cm": "fe2",
        "Fe3 10-20 cm": "fe3",
        "Fe4 20-40 cm": "fe4",
        "Mn1 0-20 cm": "mn1",
        "Mn2 0-10 cm": "mn2",
        "Mn3 10-20 cm": "mn3",
        "Mn4 20-40 cm": "mn4",
        "Zn1 0-20 cm": "zn1",
        "Zn2 0-10 cm": "zn2",
        "Zn3 10-20 cm": "zn3",
        "Zn4 20-40 cm": "zn4"
        })

        def load_shapefile_and_apply_style(shapefile_folder, style_folder, field_mapping):
            # Carrega o projeto QGIS
            project = QgsProject.instance()

            # Itera sobre o dicionário de mapeamento de campo na ordem reversa
            for layer_name, style_name in reversed(field_mapping.items()):
                # Caminho completo para o shapefile
                shapefile_path = f"{shapefile_folder}/{layer_name}.shp"

                # Caminho completo para o arquivo QML de estilo
                style_path = f"{style_folder}/{style_name}.qml"

                # Adiciona a camada vetorial ao projeto
                layer = QgsVectorLayer(shapefile_path, layer_name, "ogr")
                if not layer.isValid():
                    print(f"Erro ao carregar a camada {layer_name}")
                    continue

                # Aplica o estilo QML à camada
                layer.loadNamedStyle(style_path)

                # Adiciona a camada ao projeto
                project.addMapLayer(layer)


        # Caminhos para os diretórios
        shapefile_folder = r"C:\geoprocessamento\PROCESSAMENTO\FileQgis"
        style_folder = r"C:\geoprocessamento\PROCESSAMENTO\legendas"

         #Chama a função para carregar shapefiles e aplicar estilos
        if self.dlg.checkBoxCarregarLayout.isChecked() == True:
            load_shapefile_and_apply_style(shapefile_folder, style_folder, field_mapping)
        else:
            pass


        def ChamarLayerLayout(shapefile_dir, name=str, estilo=str):
            # Nome do arquivo a ser filtrado
            nome_arquivo = name

            # Caminho completo do shapefile
            shapefile_path = shapefile_dir + '/' + nome_arquivo + '.shp'

            # Carregar o shapefile no QGIS
            layer = QgsVectorLayer(shapefile_path, nome_arquivo, 'ogr')

            # Verificar se o shapefile foi carregado com sucesso
            if not layer.isValid():
                print('Falha ao carregar o shapefile.')

            # carregando estilo
            layer.loadNamedStyle('C:/geoprocessamento/estilos/' + estilo)
            layer.triggerRepaint()

            # Obter a soma da coluna "HECTARES" e arredondar
            hectares_sum = layer.aggregate(QgsAggregateCalculator.Sum, "HECTARES")[0]
            hectares_sum = round(float(hectares_sum), 1)

            # Atualizar o nome do layer com a informação correta
            layer.setName(f"Área total - {hectares_sum} ha")

            # Criar um novo campo 'IDHA' com auto-incremento (se ainda não existir)
            id_field_name = 'IDHA'
            idx = layer.fields().indexFromName(id_field_name)
            if idx == -1:
                new_field = QgsField(id_field_name, QVariant.Int)
                layer.dataProvider().addAttributes([new_field])
                layer.updateFields()

                # Calcula o auto-incremento para o novo campo 'IDHA'
                expression = QgsExpression('$id')
                context = QgsExpressionContext()
                with edit(layer):
                    for feature in layer.getFeatures():
                        context.setFeature(feature)
                        feature[id_field_name] = expression.evaluate(context)
                        layer.updateFeature(feature)

                print(f"Auto-incrementing field '{id_field_name}' added and calculated successfully.")
            else:
                print(f"Field '{id_field_name}' already exists. Skipping creation.")

            # Adicionar o layer ao projeto do QGIS
            QgsProject.instance().addMapLayer(layer)
            # Duplicate the layer
            duplicated_layer = layer.clone()
            
            # Load the 'hectares.qml' style for the duplicated layer
            duplicated_layer.loadNamedStyle('C:/geoprocessamento/estilos/' + 'hectares.qml')
            duplicated_layer.triggerRepaint()
            QgsProject.instance().addMapLayer(duplicated_layer)
            
        shapefile_dir = r"C:\geoprocessamento\PROCESSAMENTO\FileQgis"
        ChamarLayerLayout(shapefile_dir, name = 'co_original', estilo = 'talhao.qml')

        def CtcArgila():
            Camada = [
                "CTC1 0-20 cm",
                "CTC2 0-10 cm",
                "CTC3 10-20 cm",
                "CTC4 20-40 cm",
                "CTC5 40-60 cm",
                "CTC6 60-80 cm",
                "CTC7 80-100 cm",
                "Argila1 0-20 cm",
                "Argila2 0-10 cm",
                "Argila3 10-20 cm",
                "Argila4 20-40 cm"
            ]

            for c in Camada:
                # Try to get the layer by name
                layers = QgsProject.instance().mapLayersByName(c)

                # Check if the layer was found
                if layers:
                    layer = layers[0]  # Access the first layer in the list
                    print(f"Layer '{c}' found:", layer)
                    renderer = layer.renderer()

                    renderer.updateClasses(layer, 2, 5)  # Update the QgsGraduatedSymbologyRenderer.mode and set the classes up to 5
                    renderer.updateRangeLabels()  # Update label range
                    renderer.updateColorRamp()  # Update the color ramp
                    iface.layerTreeView().refreshLayerSymbology(layer.id())  # Refresh legend on the interface
                    layer.reload()
                    # Do something with the layer (add your logic here)
                else:
                    print(f"Layer '{c}' not found in the QGIS project.")
                    # Continue to the next iteration

        # Call the function
        CtcArgila()
        
    def LimparCacheArquivos(self):
        import os
        import shutil

       
           
        def limpar_pasta_geoprocessamento():
            caminho_base = r'C:\geoprocessamento\PROCESSAMENTO'
            subpastas = ['apresentacao', 'FileQgis', 'point', 'poligono', 'rec', 'saida']

            try:
                # Verifica se o caminho base existe
                if os.path.exists(caminho_base):
                    # Percorre as subpastas e exclui os conteúdos
                    for subpasta in subpastas:
                        caminho_subpasta = os.path.join(caminho_base, subpasta)

                        try:
                            # Verifica se a subpasta existe
                            if os.path.exists(caminho_subpasta):
                                # Remove todos os arquivos e subpastas dentro da subpasta
                                for nome_arquivo in os.listdir(caminho_subpasta):
                                    caminho_arquivo = os.path.join(caminho_subpasta, nome_arquivo)

                                    try:
                                        if os.path.isfile(caminho_arquivo):
                                            os.unlink(caminho_arquivo)
                                        elif os.path.isdir(caminho_arquivo):
                                            shutil.rmtree(caminho_arquivo)
                                    except Exception as e:
                                        print(f'Erro ao excluir {caminho_arquivo}: {e}')

                                print(f'Todos os arquivos em {caminho_subpasta} foram excluídos com sucesso.')
                            else:
                                print(f'A subpasta {caminho_subpasta} não existe.')

                        except Exception as e:
                            print(f'Erro ao acessar a subpasta {caminho_subpasta}: {e}')

                else:
                    print(f'O caminho base {caminho_base} não existe.')

            except Exception as e:
                print(f'Erro ao limpar a pasta Geoprocessamento: {e}')

        # Chamando a função para limpar a pasta Geoprocessamento
        limpar_pasta_geoprocessamento()
     
    def handleCheckboxStateProcessarIndividual(self):

        if self.dlg.checkBoxProcessarIndividual.isChecked() == True:
        #bloco será executado somente se o QCheckBox estiver marcado
           
            self.dlg.groupBoxIndividual.setEnabled(True)
        else:
            self.dlg.groupBoxIndividual.setEnabled(False)    
    
    def ProcessarAutomatico(self):
        self.exportar_poligono_e_pontos()
        
    def ProcessarIndividualmente(self):
        self.ProcessarIndividual()
           
    def OrganizarContornoPerfil(self):
        
        camada_fazenda = self.dlg.mMapLayerComboBoxFazenda.currentLayer()
       
   
        def exportar_features_selecionadas(caminho_saida):
        # Obtenha o projeto QGIS
            
            
            # Obtenha o layer ativo no QGIS (certifique-se de que seu layer de polígonos está ativo)
            layer = camada_fazenda
            

            # Verifique se o layer é do tipo vetor (polígono ou multipolígono)
            if layer.geometryType() in [QgsWkbTypes.PolygonGeometry, QgsWkbTypes.MultiPolygon]:
                # Obtenha as features selecionadas
                selected_features = layer.selectedFeatures()

                # Criar uma lista para armazenar as features exportadas
                exported_features = []

                # Iterar sobre as features selecionadas
                for feature in selected_features:
                    # Obter a geometria e a área
                    geometry = feature.geometry()
                    area = geometry.area()

                    # Adicionar a feature e a área à lista de features exportadas
                    exported_features.append((feature, area))

                # Escrever as features exportadas para um novo shapefile
                QgsVectorFileWriter.writeAsVectorFormat(layer, caminho_saida, 'UTF-8', layer.crs(), 'ESRI Shapefile', onlySelected=True)

                print(f"As features selecionadas foram exportadas para {caminho_saida}")

            else:
                print("O layer ativo não é do tipo polígono ou multipolígono.")
                

        def SelecionarCampos(campos_desejados, shapefile_saida):
            try:
                # Lê a camada de entrada como GeoDataFrame
                gdf = gpd.read_file('C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')

                # Verifica se os campos desejados estão presentes no GeoDataFrame
                campos_faltantes = [campo for campo in campos_desejados if campo not in gdf.columns]

                if campos_faltantes:
                    raise ValueError(f"Os campos {campos_faltantes} não estão presentes na camada de entrada.")

                # Seleciona apenas os campos desejados
                gdf_selecionado = gdf[campos_desejados].copy()

                # Converte o DataFrame resultante de volta para GeoDataFrame
                gdf_selecionado = gpd.GeoDataFrame(gdf_selecionado, geometry=gdf.geometry)

                # Salva o GeoDataFrame resultante no novo shapefile
                gdf_selecionado.to_file(shapefile_saida, driver='ESRI Shapefile')
            except:
                pass

        def obter_camadas_de_pontos():
            # Obtém a lista de camadas no projeto
            camadas = QgsProject.instance().mapLayers().values()

            # Filtra apenas as camadas de pontos
            camadas_de_pontos = [camada for camada in camadas if camada.type() == QgsMapLayerType.VectorLayer and camada.geometryType() == QgsWkbTypes.PointGeometry]
        
            return camadas_de_pontos
        
        def recortar_e_carregar_camadas():
            lista_perfil = obter_camadas_de_pontos()
            for p in lista_perfil:
                recortar = processing.run('native:clip', {
                    'INPUT': p,
                    'OVERLAY': 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp',
                    'OUTPUT': os.path.join('C:/geoprocessamento/PROCESSAMENTO/point', f'{p.name()}_parcial.shp')
                })
                
                output_recorte = recortar['OUTPUT']
                
                # Criar um objeto QgsVectorLayer a partir do caminho do arquivo
                layer_recortada = QgsVectorLayer(output_recorte, f'{p.name()}_parcial', 'ogr')
                
                # Verificar se a camada foi carregada corretamente
                if layer_recortada.isValid():
                    QgsProject.instance().addMapLayer(layer_recortada)
                else:
                    print(f"Erro ao carregar a camada recortada: {layer_recortada.dataProvider().error().message()}")
        
        def BufferShapefile():
            # Lê o shapefile de entrada
            gdf = gpd.read_file('C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')

            # Converte a distância de metros para graus (WGS84)
            buffer_distance_degrees = 1 / 111320  # Aproximadamente 111320 metros por grau

            # Aplica o buffer ao GeoDataFrame
            gdf['geometry'] = gdf['geometry'].buffer(buffer_distance_degrees)

            # Salva o novo shapefile com o buffer
            gdf.to_file('C:/geoprocessamento/PROCESSAMENTO/poligono/co_buffer.shp')
    
        exportar_features_selecionadas(caminho_saida = 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')
        SelecionarCampos(['CLIENTE', 'FAZENDA', 'TALHAO', 'BLOCO','GRID', 'HECTARES'], 'C:/geoprocessamento/PROCESSAMENTO/poligono/co.shp')  
        recortar_e_carregar_camadas()
        BufferShapefile()
    
    def ProcessarIndividual(self):
        
        def ItemLista():
            itens_selecionados = self.dlg.listWidgetAtributos.selectedItems()

            # Cria uma lista para armazenar as informações dos itens selecionados
            informacoes_selecionadas = []

            # Itera sobre os itens selecionados e extrai as informações
            for item in itens_selecionados:
                informacao = item.text().upper()  # Substitua isso pela lógica real para obter as informações do item
                informacoes_selecionadas.append(informacao)
            
        # Agora, informacoes_selecionadas contém as informações dos itens selecionados
            return informacoes_selecionadas
        
        selected_columns = ItemLista() 

        def Add_Coordenadas_OrganizarDataFrame_Dentro_Da_Pasta():
            folder_path = 'C:/geoprocessamento/PROCESSAMENTO/point/' 
            # Lista todos os arquivos na pasta com a extensão .shp
            shapefile_paths = [os.path.join(folder_path, file) for file in os.listdir(folder_path) if file.endswith('.shp')]

            # Lista para armazenar os DataFrames organizados
            organized_gdfs = []

            for shapefile_path in shapefile_paths:
                gdf = gpd.read_file(shapefile_path)

                # Verifica se o shapefile contém as colunas 'geometry'
                if 'geometry' in gdf.columns:
                    # Extrai as coordenadas X e Y em colunas separadas
                    gdf['X'] = gdf['geometry'].x
                    gdf['Y'] = gdf['geometry'].y

                    # Converte os nomes das colunas para maiúsculas
                    gdf.columns = map(str.upper, gdf.columns)

                    # Reorganiza as colunas do DataFrame
                    gdf = gdf[['X', 'Y'] + [col for col in gdf.columns if col not in ['X', 'Y']]]

                    organized_gdfs.append(gdf)
                else:
                    print(f"O shapefile {shapefile_path} não contém a coluna 'geometry'.")

            return organized_gdfs
            
        def Remove_Columns_Change_Value_Equal(gdf, columns_to_remove=None):
            if columns_to_remove is None:
                columns_to_remove = ['ID', 'LAB', 'LOTE', 'PROF', 'GEOMETRY']

            # Remove the specified columns
            gdf = gdf.drop(columns=columns_to_remove)

            for coluna in gdf.columns:
                if gdf[coluna].nunique() == 1:
                    # If all values in the column are equal
                    # Choose a random index to add the value
                    indice_aleatorio = random.randint(0, len(gdf) - 1)
                    gdf.at[indice_aleatorio, coluna] += 0.00000000000001

            return gdf
            
        def Exportar_Csv_Todos_Atributos(gdf, output_folder):
            # Garante que o diretório de saída existe
            os.makedirs(output_folder, exist_ok=True)

            # Obtém uma lista de todas as colunas, exceto 'X' e 'Y'
            columns_to_export = [col for col in gdf.columns if col not in ['X', 'Y']]

            # Itera sobre as colunas a serem exportadas
            for column in columns_to_export:
                # Verifica se algum valor na coluna está vazio
                if gdf[column].notna().any():
                    # Se algum valor não estiver vazio, crie o arquivo CSV
                    # Cria o nome do arquivo CSV com base no nome da coluna
                    csv_filename = f"{column}.csv"
                    csv_path = os.path.join(output_folder, csv_filename)

                    # Seleciona as colunas 'X', 'Y' e a coluna atual
                    selected_data = gdf[['X', 'Y', column]]

                    # Exporta os dados para o arquivo CSV
                    selected_data.to_csv(csv_path, index=False)

        def Exportar_Csv_Em_Loop():
            for idx, cleaned_gdf in enumerate(cleaned_gdfs):
                Exportar_Csv_Todos_Atributos(cleaned_gdf, output_folder = 'C:/geoprocessamento/PROCESSAMENTO/saida/' )
                
        def Remover_Csv_Que_Nao_Ira_Processar(keys_list):
            caminho_pasta = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            # Lista todos os arquivos na pasta
            arquivos_na_pasta = os.listdir(caminho_pasta)

            # Filtra apenas os arquivos CSV
            arquivos_csv = [arquivo for arquivo in arquivos_na_pasta if arquivo.endswith('.csv')]

            # Identifica os arquivos a serem removidos
            arquivos_a_remover = [arquivo for arquivo in arquivos_csv if arquivo[:-4] not in keys_list]

            # Remove os arquivos indesejados
            for arquivo in arquivos_a_remover:
                caminho_arquivo = os.path.join(caminho_pasta, arquivo)
                os.remove(caminho_arquivo)
                print(f"Arquivo removido: {arquivo}")

        def Renomear_Csv_Padrao_Terram():
            directory = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            name_mapping = {
            "ARGILA1": "Argila1 0-20 cm",
            "ARGILA2": "Argila2 0-10 cm",
            "ARGILA3": "Argila3 10-20 cm",
            "ARGILA4": "Argila4 20-40 cm",
            "MO1": "Mo1 0-20 cm",
            "MO2": "Mo2 0-10 cm",
            "MO3": "Mo3 10-20 cm",
            "MO4": "Mo4 20-40 cm",
            "PH1": "pH1 0-20 cm",
            "PH2": "pH2 0-10 cm",
            "PH3": "pH3 10-20 cm",
            "PH4": "pH4 20-40 cm",
            "CTC1": "CTC1 0-20 cm",
            "CTC2": "CTC2 0-10 cm",
            "CTC3": "CTC3 10-20 cm",
            "CTC4": "CTC4 20-40 cm",
            "CTC5": "CTC5 40-60 cm",
            "CTC6": "CTC6 60-80 cm",
            "CTC7": "CTC7 80-100 cm",
            "V1": "V1 0-20 cm",
            "V2": "V2 0-10 cm",
            "V3": "V3 10-20 cm",
            "V4": "V4 20-40 cm",
            "V5": "V5 40-60 cm",
            "V6": "V6 60-80 cm",
            "V7": "V7 80-100 cm",
            "CA1": "Ca1 0-20 cm",
            "CA2": "Ca2 0-10 cm",
            "CA3": "Ca3 10-20 cm",
            "CA4": "Ca4 20-40 cm",
            "CA5": "Ca5 40-60 cm",
            "CA6": "Ca6 60-80 cm",
            "CA7": "Ca7 80-100 cm",
            "SAT_CA1": "Sat_Ca1 0-20 cm",
            "SAT_CA2": "Sat_Ca2 0-10 cm",
            "SAT_CA3": "Sat_Ca3 10-20 cm",
            "SAT_CA4": "Sat_Ca4 20-40 cm",
            "MG1": "Mg1 0-20 cm",
            "MG2": "Mg2 0-10 cm",
            "MG3": "Mg3 10-20 cm",
            "MG4": "Mg4 20-40 cm",
            "SAT_MG1": "Sat_Mg1 0-20 cm",
            "SAT_MG2": "Sat_Mg2 0-10 cm",
            "SAT_MG3": "Sat_Mg3 10-20 cm",
            "SAT_MG4": "Sat_Mg4 20-40 cm",
            "REL_CA_MG1": "Rel_Ca_Mg1 0-20 cm",
            "REL_CA_MG2": "Rel_Ca_Mg2 0-10 cm",
            "REL_CA_MG3": "Rel_Ca_Mg3 10-20 cm",
            "REL_CA_MG4": "Rel_Ca_Mg4 20-40 cm",
            "K1": "K1 0-20 cm",
            "K2": "K2 0-10 cm",
            "K3": "K3 10-20 cm",
            "K4": "K4 20-40 cm",
            "SAT_K1": "Sat_K1 0-20 cm",
            "SAT_K2": "Sat_K2 0-10 cm",
            "SAT_K3": "Sat_K3 10-20 cm",
            "SAT_K4": "Sat_K4 20-40 cm",
            "P_MEH1": "P_meh1 0-20 cm",
            "P_MEH2": "P_meh2 0-10 cm",
            "P_MEH3": "P_meh3 10-20 cm",
            "P_MEH4": "P_meh4 20-40 cm",
            "P_REM1": "P_rem1 0-20 cm",
            "P_REM2": "P_rem2 0-10 cm",
            "P_REM3": "P_rem3 10-20 cm",
            "P_REM4": "P_rem4 20-40 cm",
            "P_RES1": "P_res1 0-20 cm",
            "P_RES2": "P_res2 0-10 cm",
            "P_RES3": "P_res3 10-20 cm",
            "P_RES4": "P_res4 20-40 cm",
            "AL1": "Al1 0-20 cm",
            "AL2": "Al2 0-10 cm",
            "AL3": "Al3 10-20 cm",
            "AL4": "Al4 20-40 cm",
            "AL5": "Al5 40-60 cm",
            "AL6": "Al6 60-80 cm",
            "AL7": "Al7 80-100 cm",
            "SAT_AL1": "Sat_Al1 0-20 cm",
            "SAT_AL2": "Sat_Al2 0-10 cm",
            "SAT_AL3": "Sat_Al3 10-20 cm",
            "SAT_AL4": "Sat_Al4 20-40 cm",
            "S1": "S1 0-20 cm",
            "S2": "S2 0-10 cm",
            "S3": "S3 10-20 cm",
            "S4": "S4 20-40 cm",
            "S5": "S5 40-60 cm",
            "S6": "S6 60-80 cm",
            "S7": "S7 80-100 cm",
            "B1": "B1 0-20 cm",
            "B2": "B2 0-10 cm",
            "B3": "B3 10-20 cm",
            "B4": "B4 20-40 cm",
            "CU1": "Cu1 0-20 cm",
            "CU2": "Cu2 0-10 cm",
            "CU3": "Cu3 10-20 cm",
            "CU4": "Cu4 20-40 cm",
            "FE1": "Fe1 0-20 cm",
            "FE2": "Fe2 0-10 cm",
            "FE3": "Fe3 10-20 cm",
            "FE4": "Fe4 20-40 cm",
            "MN1": "Mn1 0-20 cm",
            "MN2": "Mn2 0-10 cm",
            "MN3": "Mn3 10-20 cm",
            "MN4": "Mn4 20-40 cm",
            "ZN1": "Zn1 0-20 cm",
            "ZN2": "Zn2 0-10 cm",
            "ZN3": "Zn3 10-20 cm",
            "ZN4": "Zn4 20-40 cm"
        }
            
            for filename in os.listdir(directory):
                if filename.endswith(".csv"):
                    old_path = os.path.join(directory, filename)
                    
                    # Extracting the key from the filename
                    key = filename.split(".")[0].upper()
                    
                    # Checking if the key exists in the mapping
                    if key in name_mapping:
                        new_filename = name_mapping[key] + "." + filename.split(".", 1)[1]
                        new_path = os.path.join(directory, new_filename)
                        
                        # Renaming the file
                        os.rename(old_path, new_path)
                        print(f"Renamed: {filename} -> {new_filename}")
                    else:
                        print(f"Key not found in mapping: {key} for file {filename}")

        def Csv_To_Dat():
            input_folder = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            output_folder = 'C:/geoprocessamento/PROCESSAMENTO/saida/'
            # Verifique se as pastas de entrada e saída existem, e se não, crie-as
            if not os.path.exists(output_folder):
                os.makedirs(output_folder)

            # Lista de arquivos na pasta de entrada
            csv_files = [f for f in os.listdir(input_folder) if f.endswith('.csv')]

            for csv_file in csv_files:
                # Crie o caminho completo para o arquivo de entrada
                input_path = os.path.join(input_folder, csv_file)

                # Leia o arquivo CSV em um DataFrame do pandas
                df = pd.read_csv(input_path)

                # Crie o nome do arquivo de saída com a extensão .dat
                dat_file = os.path.splitext(csv_file)[0] + '.dat'

                # Crie o caminho completo para o arquivo de saída
                output_path = os.path.join(output_folder, dat_file)

                # Salve o DataFrame no arquivo .dat usando um delimitador de sua escolha (por exemplo, espaço)
                df.to_csv(output_path, sep=' ', index=False)
       
        organized_gdfs = Add_Coordenadas_OrganizarDataFrame_Dentro_Da_Pasta()
        cleaned_gdfs = [Remove_Columns_Change_Value_Equal(gdf) for gdf in organized_gdfs]
        Exportar_Csv_Em_Loop()  
        Remover_Csv_Que_Nao_Ira_Processar(keys_list = selected_columns) 
        Renomear_Csv_Padrao_Terram()
        Csv_To_Dat()
    
    def ChamarLayoutIndividual(self):
        from qgis.core import QgsProject, QgsVectorLayer
        from collections import OrderedDict
        import qgis.core
        import re
    
    
        field_mapping = OrderedDict({
        "rec": "v2",
        "Argila1 0-20 cm": "argila1",
        "Argila2 0-10 cm": "argila2",
        "Argila3 10-20 cm": "argila3",
        "Argila4 20-40 cm": "argila4",
        "Mo1 0-20 cm": "mo1",
        "Mo2 0-10 cm": "mo2",
        "Mo3 10-20 cm": "mo3",
        "Mo4 20-40 cm": "mo4",
        "CTC1 0-20 cm": "ctc1",
        "CTC2 0-10 cm": "ctc2",
        "CTC3 10-20 cm": "ctc3",
        "CTC4 20-40 cm": "ctc4",
        "CTC5 40-60 cm": "ctc5",
        "CTC6 60-80 cm": "ctc6",
        "CTC7 80-100 cm": "ctc7",
        "pH1 0-20 cm": "ph1",
        "pH2 0-10 cm": "ph2",
        "pH3 10-20 cm": "ph3",
        "pH4 20-40 cm": "ph4",
        "V1 0-20 cm": "v1",
        "V2 0-10 cm": "v2",
        "V3 10-20 cm": "v3",
        "V4 20-40 cm": "v4",
        "V5 40-60 cm": "v5",
        "V6 60-80 cm": "v6",
        "V7 80-100 cm": "v7",
        "Ca1 0-20 cm": "ca1",
        "Ca2 0-10 cm": "ca2",
        "Ca3 10-20 cm": "ca3",
        "Ca4 20-40 cm": "ca4",
        "Ca5 40-60 cm": "ca5",
        "Ca6 60-80 cm": "ca6",
        "Ca7 80-100 cm": "ca7",
        "Sat_Ca1 0-20 cm": "sat_ca1",
        "Sat_Ca2 0-10 cm": "sat_ca2",
        "Sat_Ca3 10-20 cm": "sat_ca3",
        "Sat_Ca4 20-40 cm": "sat_ca4",
        "Mg1 0-20 cm": "mg1",
        "Mg2 0-10 cm": "mg2",
        "Mg3 10-20 cm": "mg3",
        "Mg4 20-40 cm": "mg4",
        "Sat_Mg1 0-20 cm": "sat_mg1",
        "Sat_Mg2 0-10 cm": "sat_mg2",
        "Sat_Mg3 10-20 cm": "sat_mg3",
        "Sat_Mg4 20-40 cm": "sat_mg4",
        "Rel_Ca_Mg1 0-20 cm": "rel_ca_mg1",
        "Rel_Ca_Mg2 0-10 cm": "rel_ca_mg2",
        "Rel_Ca_Mg3 10-20 cm": "rel_ca_mg3",
        "Rel_Ca_Mg4 20-40 cm": "rel_ca_mg4",
        "K1 0-20 cm": "k1",
        "K2 0-10 cm": "k2",
        "K3 10-20 cm": "k3",
        "K4 20-40 cm": "k4",
        "Sat_K1 0-20 cm": "sat_k1",
        "Sat_K2 0-10 cm": "sat_k2",
        "Sat_K3 10-20 cm": "sat_k3",
        "Sat_K4 20-40 cm": "sat_k4",
        "P_meh1 0-20 cm": "p_meh1",
        "P_meh2 0-10 cm": "p_meh2",
        "P_meh3 10-20 cm": "p_meh3",
        "P_meh4 20-40 cm": "p_meh4",
        "P_rem1 0-20 cm": "p_rem1",
        "P_rem2 0-10 cm": "p_rem2",
        "P_rem3 10-20 cm": "p_rem3",
        "P_rem4 20-40 cm": "p_rem4",
        "P_res1 0-20 cm": "p_res1",
        "P_res2 0-10 cm": "p_res2",
        "P_res3 10-20 cm": "p_res3",
        "P_res4 20-40 cm": "p_res4",
        "Al1 0-20 cm": "al1",
        "Al2 0-10 cm": "al2",
        "Al3 10-20 cm": "al3",
        "Al4 20-40 cm": "al4",
        "Al5 40-60 cm": "al5",
        "Al6 60-80 cm": "al6",
        "Al7 80-100 cm": "al7",
        "Sat_Al1 0-20 cm": "sat_al1",
        "Sat_Al2 0-10 cm": "sat_al2",
        "Sat_Al3 10-20 cm": "sat_al3",
        "Sat_Al4 20-40 cm": "sat_al4",
        "S1 0-20 cm": "s1",
        "S2 0-10 cm": "s2",
        "S3 10-20 cm": "s3",
        "S4 20-40 cm": "s4",
        "S5 40-60 cm": "s5",
        "S6 60-80 cm": "s6",
        "S7 80-100 cm": "s7",
        "B1 0-20 cm": "b1",
        "B2 0-10 cm": "b2",
        "B3 10-20 cm": "b3",
        "B4 20-40 cm": "b4",
        "Cu1 0-20 cm": "cu1",
        "Cu2 0-10 cm": "cu2",
        "Cu3 10-20 cm": "cu3",
        "Cu4 20-40 cm": "cu4",
        "Fe1 0-20 cm": "fe1",
        "Fe2 0-10 cm": "fe2",
        "Fe3 10-20 cm": "fe3",
        "Fe4 20-40 cm": "fe4",
        "Mn1 0-20 cm": "mn1",
        "Mn2 0-10 cm": "mn2",
        "Mn3 10-20 cm": "mn3",
        "Mn4 20-40 cm": "mn4",
        "Zn1 0-20 cm": "zn1",
        "Zn2 0-10 cm": "zn2",
        "Zn3 10-20 cm": "zn3",
        "Zn4 20-40 cm": "zn4",
        "Argila1 0-25 cm": "argila1",
        "Argila4 25-50 cm": "argila4",
        "Mo1 0-25 cm": "mo1",
        "Mo4 25-50 cm": "mo4",
        "CTC1 0-25 cm": "ctc1",
        "CTC4 25-50 cm": "ctc4",
        "pH1 0-25 cm": "ph1",
        "pH4 25-50 cm": "ph4",
        "V1 0-25 cm": "v1",
        "V4 25-50 cm": "v4",
        "Ca1 0-25 cm": "ca1",
        "Ca4 25-50 cm": "ca4",
        "Sat_Ca1 0-25 cm": "sat_ca1",
        "Sat_Ca4 25-50 cm": "sat_ca4",
        "Mg1 0-25 cm": "mg1",
        "Mg4 25-50 cm": "mg4",
        "Sat_Mg1 0-25 cm": "sat_mg1",
        "Sat_Mg4 25-50 cm": "sat_mg4",
        "Rel_Ca_Mg1 0-25 cm": "rel_ca_mg1",
        "Rel_Ca_Mg4 25-50 cm": "rel_ca_mg4",
        "K1 0-25 cm": "k1",
        "K4 25-50 cm": "k4",
        "Sat_K1 0-25 cm": "sat_k1",
        "Sat_K4 25-50 cm": "sat_k4",
        "P_meh1 0-25 cm": "p_meh1",
        "P_meh4 25-50 cm": "p_meh4",
        "P_rem1 0-25 cm": "p_rem1",
        "P_rem4 25-50 cm": "p_rem4",
        "P_res1 0-25 cm": "p_res1",
        "P_res4 25-50 cm": "p_res4",
        "Al1 0-25 cm": "al1",
        "Al4 25-50 cm": "al4",
        "Sat_Al1 0-25 cm": "sat_al1",
        "Sat_Al4 25-50 cm": "sat_al4",
        "S1 0-25 cm": "s1",
        "S4 25-50 cm": "s4",
        "B1 0-25 cm": "b1",
        "B4 25-50 cm": "b4",
        "Cu1 0-25 cm": "cu1",
        "Cu4 25-50 cm": "cu4",
        "Fe1 0-25 cm": "fe1",
        "Fe4 25-50 cm": "fe4",
        "Mn1 0-25 cm": "mn1",
        "Mn4 25-50 cm": "mn4",
        "Zn1 0-25 cm": "zn1",
        "Zn4 25-50 cm": "zn4"
        })
               
        def load_shapefiles_and_apply_style(shapefile_folder, style_folder, field_mapping, shapefile_list):
            # Carrega o projeto QGIS
            project = QgsProject.instance()

            # Itera sobre a lista de shapefiles desejados
            for shapefile_name in shapefile_list:
                # Obtém o nome da camada e do estilo usando o mapeamento de campo
                layer_name = os.path.splitext(shapefile_name)[0]
                print(layer_name)
                style_name = field_mapping.get(layer_name)

                if not style_name:
                    print(f"Estilo não encontrado para a camada {layer_name}")
                    continue

                # Caminho completo para o shapefile
                shapefile_path = os.path.join(shapefile_folder, shapefile_name)

                # Adiciona a camada vetorial ao projeto
                layer = QgsVectorLayer(shapefile_path, layer_name, "ogr")
                if not layer.isValid():
                    print(f"Erro ao carregar a camada {layer_name}")
                    continue

                # Caminho completo para o arquivo QML de estilo
                style_path = os.path.join(style_folder, f"{style_name}.qml")

                # Aplica o estilo QML à camada
                layer.loadNamedStyle(style_path)

                # Adiciona a camada ao projeto
                project.addMapLayer(layer)


        # Caminho para os diretórios
        shapefile_folder = r"C:\geoprocessamento\PROCESSAMENTO\FileQgis"
        style_folder = r"C:\geoprocessamento\PROCESSAMENTO\legendas"

        shapefile_paths_str = self.dlg.mQgsFileWidget.filePath()  # Assuming this returns a string like "Ca2 0-10 cm.shp CTC2 0-10 cm.shp"
        print(shapefile_paths_str)
        # Usa regex para extrair os caminhos dentro das aspas
        shapefile_paths_list = re.findall(r'"(.*?)"', shapefile_paths_str)
        shapefile_list = shapefile_paths_list
        

        # Chama a função para carregar shapefiles e aplicar estilos
        load_shapefiles_and_apply_style(shapefile_folder, style_folder, field_mapping, shapefile_list)
        
  

 

        def CtcArgila():
            Camada = [
                "CTC1 0-20 cm",
                "CTC1 0-25 cm",
                "CTC2 0-10 cm",
                "CTC3 10-20 cm",
                "CTC4 20-40 cm",
                "CTC4 25-50 cm",
                "CTC5 40-60 cm",
                "CTC6 60-80 cm",
                "CTC7 80-100 cm",
                "Argila1 0-20 cm",
                "Argila1 0-25 cm",
                "Argila2 0-10 cm",
                "Argila3 10-20 cm",
                "Argila4 20-40 cm",
                "Argila4 25-50 cm"
            ]

            for c in Camada:
                # Try to get the layer by name
                layers = QgsProject.instance().mapLayersByName(c)

                # Check if the layer was found
                if layers:
                    layer = layers[0]  # Access the first layer in the list
                    print(f"Layer '{c}' found:", layer)
                    renderer = layer.renderer()

                    renderer.updateClasses(layer, 2, 5)  # Update the QgsGraduatedSymbologyRenderer.mode and set the classes up to 5
                    renderer.updateRangeLabels()  # Update label range
                    renderer.updateColorRamp()  # Update the color ramp
                    iface.layerTreeView().refreshLayerSymbology(layer.id())  # Refresh legend on the interface
                    layer.reload()
                    # Do something with the layer (add your logic here)
                else:
                    print(f"Layer '{c}' not found in the QGIS project.")
                    # Continue to the next iteration

        # Call the function
        CtcArgila()
        #time.sleep(3.0)           
    def Replace(self):
    
    
        def renomear_arquivos(pasta, parte_a_substituir, substituicao):
            # Obtém a lista de arquivos na pasta
            arquivos = os.listdir(pasta)

            # Itera sobre os arquivos na pasta
            for arquivo in arquivos:
                # Verifica se o arquivo é um arquivo regular
                caminho_arquivo = os.path.join(pasta, arquivo)
                if os.path.isfile(caminho_arquivo):
                    # Renomeia o arquivo substituindo a parte especificada
                    novo_nome = arquivo.replace(parte_a_substituir, substituicao)
                    
                    # Renomeia o arquivo apenas se o nome for alterado
                    if novo_nome != arquivo:
                        novo_caminho_arquivo = os.path.join(pasta, novo_nome)
                        os.rename(caminho_arquivo, novo_caminho_arquivo)
                        print(f"Arquivo renomeado: {arquivo} -> {novo_nome}")

        # Exemplo de uso
        pasta_geoprocessamento = r'C:\geoprocessamento\PROCESSAMENTO\FileQgis'
        parte_a_substituir = self.dlg.lineEditDe.text()
        substituicao = self.dlg.lineEditPara.text()
        renomear_arquivos(pasta_geoprocessamento, parte_a_substituir, substituicao)
        from PyQt5.QtWidgets import QMessageBox
        # Exibindo a caixa de diálogo após a conclusão da função
        msg_box = QMessageBox()
        msg_box.setWindowTitle("Processo Concluído")
        msg_box.setText("O processo de Renomeação Foi concluído!")
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
    
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = TerramProcessamentoDialog()
            self.perfis_individuais_instance = PerfisIndividuais(self.dlg)
            
            

        # show the dialog
        self.dlg.show()
        self.perfis_individuais_instance.dlg.show()
        
        
       
        
        ## Processamento individual
        self.dlg.pushButtonOrganizar.clicked.connect(self.LimparCacheArquivos)
        self.dlg.checkBoxProcessarIndividual.stateChanged.connect(self.handleCheckboxStateProcessarIndividual)
        self.dlg.pushButtonOrganizar.clicked.connect(self.OrganizarContornoPerfil)
        self.dlg.pushButtonCarregar.clicked.connect(self.ChamarLayoutIndividual)
        self.dlg.pushButtonProcessarIndividual.clicked.connect(self.ProcessarIndividualmente)
        self.dlg.pushButtonProcessarIndividual.clicked.connect(self.PrepararParametrosBas)
        self.dlg.pushButtonProcessarIndividual.clicked.connect(self.ExcutarSubProcessoSurfer8)
        self.dlg.pushButtonProcessarIndividual.clicked.connect(self.PrepararShapefileRecApresentacao)
        
        ## Replace
        self.dlg.pushButtonReplace.clicked.connect(self.Replace)
        
        
        
        ##Processamento automatico
        self.dlg.pushButtonProcessar.clicked.connect(self.LimparCacheArquivos)
        self.dlg.pushButtonProcessar.clicked.connect(self.ProcessarAutomatico)
        self.dlg.pushButtonProcessar.clicked.connect(self.PrepararCSVeDAT)
        self.dlg.pushButtonProcessar.clicked.connect(self.PrepararParametrosBas)
        self.dlg.pushButtonProcessar.clicked.connect(self.ExcutarSubProcessoSurfer8)
        self.dlg.pushButtonProcessar.clicked.connect(self.PrepararShapefileRecApresentacao)
        self.dlg.pushButtonProcessar.clicked.connect(self.PuxarLayoutELegagendas)
        
        
        
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        ## Processamento individual
        self.dlg.pushButtonOrganizar.clicked.disconnect(self.LimparCacheArquivos)
        self.dlg.pushButtonOrganizar.clicked.disconnect(self.OrganizarContornoPerfil)
        self.dlg.pushButtonProcessarIndividual.clicked.disconnect(self.ProcessarIndividualmente)
        self.dlg.pushButtonCarregar.clicked.disconnect(self.ChamarLayoutIndividual)
        
        ## Replace
        self.dlg.pushButtonReplace.clicked.disconnect(self.Replace)
        
        ##Processamento automatico
        self.dlg.pushButtonProcessar.clicked.disconnect(self.LimparCacheArquivos)
        self.dlg.pushButtonProcessar.clicked.disconnect(self.ProcessarAutomatico)
        self.dlg.pushButtonProcessar.clicked.disconnect(self.PrepararCSVeDAT)
        self.dlg.pushButtonProcessar.clicked.disconnect(self.PrepararParametrosBas)
        self.dlg.pushButtonProcessar.clicked.disconnect(self.ExcutarSubProcessoSurfer8)
        self.dlg.pushButtonProcessar.clicked.disconnect(self.PrepararShapefileRecApresentacao)
        self.dlg.pushButtonProcessar.clicked.disconnect(self.PuxarLayoutELegagendas)
        
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
        
            